# Деревья

Дерево - связный граф без циклов.

Есть 3 пункта:

- Связный
- Без циклов
- |E| = |V| + 1

Достаточно выполнения любых 2х из них.

|V| = 1 <=> Это т.н. пень

### Теорема:
При |V| существуют хотя бы две висячие вершиины (Вершины степени 1).

### Доказательство:
Берём любую вершину.
1. Не изолированная, иначе не дерево
2. Идём пока можем. Мы каждый раз приходим новую вершину, так как нет циклов, следовательно, когда-то прийдём в конец.
3. Потом опять назад, получим вторую.
4. Что
5. Для любого N всегда найдётся дерево с только 2мя висячими вершинами. Например, бамбук.

# Докажем, что |E| = |V| + 1
По индукци.
База очевидна: пень.
Докажем, что при добавлении вершины вседа появится ровно одно ребро.
- Связность остаётся, если убрать висячую вершину.
- Уберём висячую вершину: она есть. Связность не нарушится.
- Пока есть цикл: убираем вершину. Получаем дерево, с меньшим количеством вершин.
- Противоречие

От противного доказываем, что несвязный граф не может быть деревом, добавляя рёбра и получая нужное соотношение рёбер и вершин.

Но получится лес: граф без циклов. (при соединении нескольких деревьев)

***Полезная фраза в теории графов***
Если убрать вершину из цикла, граф остался связным. (Если вершина )

Просто граф без циклов - лес.

Выделим корень.
Дети - непосредственно ниже.
Родитель - непосредственно
Предки - линия до корня.
Потомки - всё дерево, подвешенное к вершине.
Лист - без потомков
Висячая вершина - со степенью 1
Корень - может быть висячей вершиной, если там

# Хранение деревьев
Рёбер немного (V ~ E^1 (E - 1), а не E^2)
Храним списки детей: Kids\[vert\] = \[v1, v2, ...\]
Родители длякаждой вершины используется реже.


# Динамическое программирование с деревьями
Диаметр - масимальное из расстояний между точками фигуры.
Димаетр человеческого графа знакомств равен примерно 6
    n = 7000000000
    >>> math.log(n) / (math.log(math.log(n)))

- h\[v\] - высота поддерева с корнм в v
- d\[v\] = диаметр --""--
- a\[v\] = max L-образный путь с переломом в v

Запуск:
    dfs(root)

***Можно передавать dfs(u, prev)***


    def dfs(v):
        h\[v\] = 0
        H_max; hmax_2    
        for u in дети v:
            dfs(u)
            h\[v\] = max(h\[v\], h\[u\] + 1)

        a[v] - из hmax; hmax2
        h[v] =max из a[v], h[детей]

Все пути в дереве - Л образные!

Диаметр: максимальный из Л-обазных путей.
Для каждой вершины
